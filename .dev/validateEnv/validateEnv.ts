import { loadEnv, normalizePath } from 'vite'
import type { Plugin, ConfigEnv, UserConfig } from 'vite'
import path from 'node:path'
import fs from 'node:fs/promises'
import url from 'url'
import { z } from 'zod'
import { zodToTs, printNode } from 'zod-to-ts'

export const validateEnv = (options?: PluginOptions): Plugin => ({
    name: 'vite-plugin-validate-env',
    config: (config, env) => validate(config, env, options),
})

export type PluginOptions = {
    public: (zod: typeof z) => z.AnyZodObject
    secret: (zod: typeof z) => z.AnyZodObject
}

async function validate(userConfig: UserConfig, envConfig: ConfigEnv, options?: PluginOptions) {
    if (!options) throw new Error('Missing configuration for vite-plugin-validate-env')

    const resolvedRoot = normalizePath(
        userConfig.root ? path.resolve(userConfig.root) : process.cwd()
    )

    const envDir = userConfig.envDir
        ? normalizePath(path.resolve(resolvedRoot, userConfig.envDir))
        : resolvedRoot

    const publicEnv = loadEnv(envConfig.mode, envDir, userConfig.envPrefix)
    const secretEnv = loadEnv(envConfig.mode, envDir, '')

    const publicSchema = options.public(z)
    const publicSchemaType = zodToTs(publicSchema, 'Env')

    const secretSchema = options.secret(z)
    const secretSchemaType = zodToTs(secretSchema, 'Env')

    try {
        publicSchema.parse(publicEnv)
        secretSchema.parse(secretEnv)
    } catch (e) {
        console.error('Invalid environment variables:')
        throw e
    }

    await fs.writeFile(normalizePath(path.resolve(path.dirname(url.fileURLToPath(import.meta.url)), 'autogen-env.d.ts')), `
/// THIS FILE WAS AUTOGENERATED WITH validateEnv.
/// <reference types="vite/client" />
/// <reference types="vite-plugin-svgr/client" />

interface ImportMetaEnv ${printNode(publicSchemaType.node)}

declare namespace NodeJS {
    export interface ProcessEnv ${printNode(secretSchemaType.node)}
}
    `)
}